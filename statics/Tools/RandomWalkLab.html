<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Random Walk Lab — CoffeeQuant Tools</title>
<link rel="stylesheet" href="../css/cq.css" />

<style>
  .tool-wrap {
    max-width: 1100px;
    margin: 2rem auto;
    background: var(--panel-bg);
    border: 1px solid var(--panel-border);
    border-radius: var(--radius);
    box-shadow: var(--panel-shadow);
    padding: 1rem 1.25rem 2rem;
  }
  .tool-head {
    display:flex;
    flex-wrap:wrap;
    justify-content:space-between;
    align-items:flex-start;
    gap:1rem;
    margin-bottom:1rem;
  }
  .tool-head h1 {
    margin:0;
    font-size:1.2rem;
    line-height:1.3;
  }
  .tool-form {
    display:grid;
    grid-template-columns:repeat(auto-fit,minmax(150px,1fr));
    gap:0.75rem 1rem;
    margin-bottom:1rem;
  }
  .tool-form label {
    font-size:.8rem;
    color:var(--muted);
    display:block;
    margin-bottom:.25rem;
  }
  .tool-form input {
    width:100%;
    font-size:.9rem;
    padding:.5rem .6rem;
    border-radius:8px;
    border:1px solid var(--panel-border);
    background:var(--card-bg);
    color:var(--fg);
  }
  .tool-actions {
    display:flex;
    flex-wrap:wrap;
    gap:.5rem;
  }
  .tool-chartwrap {
    border:1px solid var(--panel-border);
    border-radius:var(--radius);
    overflow:hidden;
    background:var(--card-bg);
  }
  canvas {
    width:100%;
    height:300px;
    display:block;
  }
  .stats-row {
    font-size:.8rem;
    line-height:1.5;
    color:var(--fg);
    margin-top:1rem;
    display:flex;
    flex-wrap:wrap;
    gap:2rem;
  }
  .stats-row div {
    min-width:150px;
  }
  a.cq-logo-mini {
    text-decoration:none;
    color:var(--fg);
    font-size:.8rem;
    font-weight:600;
  }
</style>
</head>
<body>

<div class="tool-wrap">
  <div class="tool-head">
    <div>
      <h1>Random Walk Lab</h1>
      <div class="cq-muted" style="font-size:.8rem;max-width:480px;">
        Geometric Brownian Motion simulator: choose drift μ, vol σ, horizon T,
        and see sample price paths. Pure client-side — nothing sent anywhere.
      </div>
    </div>
    <div>
      <a class="cq-logo-mini" href="../../index.html">☕ CoffeeQuant Home →</a>
    </div>
  </div>

  <form class="tool-form" onsubmit="return false;">
    <div>
      <label>Initial Price S₀</label>
      <input id="rw_s0" type="number" step="0.01" value="100">
    </div>
    <div>
      <label>Drift μ (annualized %)</label>
      <input id="rw_mu" type="number" step="0.1" value="5">
    </div>
    <div>
      <label>Vol σ (annualized %)</label>
      <input id="rw_sigma" type="number" step="0.1" value="20">
    </div>
    <div>
      <label>Horizon T (years)</label>
      <input id="rw_T" type="number" step="0.1" value="1">
    </div>
    <div>
      <label>Steps per path</label>
      <input id="rw_steps" type="number" step="1" value="252">
    </div>
    <div>
      <label>Number of paths</label>
      <input id="rw_npaths" type="number" step="1" value="10">
    </div>
  </form>

  <div class="tool-actions">
    <button class="cq-btn" onclick="simulateRW()">Run</button>
    <button class="cq-btn-ghost" onclick="clearRW()">Clear</button>
  </div>

  <div class="tool-chartwrap" style="margin-top:1rem;">
    <canvas id="rw_canvas"></canvas>
  </div>

  <div id="rw_stats" class="stats-row">
    <!-- filled by JS -->
  </div>
</div>

<script>
// basic gaussian generator (Box-Muller)
function randn(){
  const u = 1-Math.random();
  const v = 1-Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

// geometric brownian motion path
function genPath(S0, mu, sigma, T, steps){
  // mu, sigma in decimals (0.05 = 5%), T in years
  // Euler log form: dS/S = mu dt + sigma dW
  const dt = T/steps;
  const path = [S0];
  for (let i=1;i<=steps;i++){
    const z = randn();
    const growth = (mu - 0.5*sigma*sigma)*dt + sigma*Math.sqrt(dt)*z;
    const prev = path[i-1];
    path.push(prev * Math.exp(growth));
  }
  return path;
}

function simulateRW(){
  const S0 = parseFloat(document.getElementById('rw_s0').value)||100;
  const mu = (parseFloat(document.getElementById('rw_mu').value)||5)/100;
  const sigma = (parseFloat(document.getElementById('rw_sigma').value)||20)/100;
  const T = parseFloat(document.getElementById('rw_T').value)||1;
  const steps = parseInt(document.getElementById('rw_steps').value)||252;
  const npaths = parseInt(document.getElementById('rw_npaths').value)||10;

  const allPaths = [];
  for(let p=0;p<npaths;p++){
    allPaths.push(genPath(S0, mu, sigma, T, steps));
  }

  drawRW(allPaths);
  summarizeRW(allPaths);
}

function clearRW(){
  const c = document.getElementById('rw_canvas');
  const ctx = c.getContext('2d');
  c.width = c.clientWidth * devicePixelRatio;
  c.height = 300 * devicePixelRatio;
  ctx.scale(devicePixelRatio, devicePixelRatio);
  ctx.clearRect(0,0,c.width,c.height);
  document.getElementById('rw_stats').innerHTML = '';
}

function drawRW(paths){
  const c = document.getElementById('rw_canvas');
  const ctx = c.getContext('2d');

  const W = c.width  = c.clientWidth * devicePixelRatio;
  const H = c.height = 300 * devicePixelRatio;
  ctx.scale(devicePixelRatio, devicePixelRatio);
  ctx.clearRect(0,0,c.width,c.height);

  // flatten all values to get min/max
  let minVal=Infinity,maxVal=-Infinity;
  for(const p of paths){
    for(const v of p){
      if(v<minVal)minVal=v;
      if(v>maxVal)maxVal=v;
    }
  }
  if(!isFinite(minVal)||!isFinite(maxVal)){
    minVal=0;maxVal=1;
  }

  // padding
  const left=40, right=10, top=10, bottom=20;
  const plotW = c.clientWidth - left - right;
  const plotH = 300 - top - bottom;

  // axes
  ctx.strokeStyle = getComputedStyle(document.body).color;
  ctx.globalAlpha=0.3;
  ctx.beginPath();
  ctx.moveTo(left, top);
  ctx.lineTo(left, top+plotH);
  ctx.lineTo(left+plotW, top+plotH);
  ctx.stroke();
  ctx.globalAlpha=1;

  // scale helpers
  function xPix(i, len){
    return left + (i/(len-1))*plotW;
  }
  function yPix(val){
    const t = (val - minVal)/(maxVal-minVal || 1);
    return top+plotH - t*plotH;
  }

  // draw each path
  ctx.lineWidth=1;
  const col = getComputedStyle(document.body).color;
  for(const p of paths){
    ctx.beginPath();
    ctx.strokeStyle = col;
    ctx.globalAlpha = 0.18;
    ctx.moveTo(xPix(0,p.length), yPix(p[0]));
    for(let i=1;i<p.length;i++){
      ctx.lineTo(xPix(i,p.length), yPix(p[i]));
    }
    ctx.stroke();
  }
  ctx.globalAlpha=1;
}

function summarizeRW(paths){
  // final values, mean, min, max
  const finals = paths.map(p=>p[p.length-1]).filter(v=>isFinite(v));
  if(!finals.length){
    document.getElementById('rw_stats').innerHTML = '';
    return;
  }
  const avg = finals.reduce((a,b)=>a+b,0)/finals.length;
  const mn = Math.min(...finals);
  const mx = Math.max(...finals);

  document.getElementById('rw_stats').innerHTML = `
    <div>
      <strong>Final mean:</strong><br>${avg.toFixed(2)}
    </div>
    <div>
      <strong>Final min / max:</strong><br>${mn.toFixed(2)} &nbsp;–&nbsp; ${mx.toFixed(2)}
    </div>
    <div>
      <strong>Obs:</strong><br>${finals.length} paths
    </div>
    <div class="cq-muted">
      Desk intuition: this shows <em>distribution of outcomes</em>, not a forecast.
    </div>
  `;
}

// draw blank state initially
clearRW();
</script>

</body>
</html>

